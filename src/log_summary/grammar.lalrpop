use crate::log_summary::model::*;
use crate::log_summary::lexer::{Lexer, Token, LexicalError};

grammar;

// Grammar
pub LogSummary: Document = {
    <_s1:SingleNewLine*> <sections:Section*> <_e:EOF> => Document { sections },
}

Section: Section = {
    <format:SectionTable> => Section::Table(format),
    <note:SectionNote> => Section::Note(note)
}

SectionNote: SectionNote = {
    <entry:Message> <_s:SingleNewLine> => SectionNote { message: entry }
}

SectionTable: SectionTable = {
    <title:SectionHeader> <_s1:SingleNewLine> <entries:SectionContent> <_s2:SingleNewLine> => {
        let entries = build_structure_by_priority(entries);
        println!("entries: {:?}", entries);
        SectionTable {
            title,
            entries
        }
    }
}

SectionHeader: String = {
    <_sep1:SectionSeparator> <_s1:SingleNewLine> <title:Title> <_s2:SingleNewLine> <_sep2:SectionSeparator> => title
}

SectionContent: Vec<Message> = {
    <entry:Entry*> => entry.into_iter().collect()
}

SectionSeparator: String = {
    <sep:SectionSeparatorLine> => {
        println!("SECTION SEPARATOR: {}", sep);
        sep.to_string()
    }
}


Entry: Message = {
    <message:Message> <_s:SingleNewLine> => message
}

Title: String = {
    <line:Line> => {
        println!("TITLE: {}", line);
        line.to_string()
    }
}

Message: Message = {
    <line:Line> => {
        let indent_level = line.to_string().chars().take_while(|c| *c == ' ').count();
        println!("MESSAGE: {}, indent_level: {}", line, indent_level);
        Message {
            indent_level: indent_level.try_into().unwrap(),
            message: line.to_string().trim().to_string()
        }
    }
}

// Token Priority
extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token {
        SingleNewLine => Token::SingleNewLine,
        SectionSeparatorLine => Token::SectionSeparatorLine(<String>),
        Line => Token::Line(<String>),
        EOF => Token::EOF,
    }
}

